
Процедура РассчитатьПланируемуюВставку(Сценарий,Ключ,ИмяФайлаНовый,мНастройки=Неопределено) Экспорт
	
	// качаем файл
	ТекстНовая = Новый ТекстовыйДокумент; 
	ТекстНовая.Прочитать(ИмяФайлаНовый,КодировкаТекста.UTF8);
	ТекстНовыйФайл = ТекстНовая.ПолучитьТекст(); 
	
	ДанныеИсходныеИзменения = ОбработкаИзмененийКонфигурацийВызовСервера.ПолучитьДанныеИсходныеИзменения(Сценарий,Ключ);
	
	ДанныеРассчитанныхИзменений = РассчитатьПланируемуюВставкуПоКлючу(ДанныеИсходныеИзменения,ТекстНовыйФайл,Сценарий,Ключ,мНастройки);
	
	// записываем новые данные по результатам 
	// удаление старых уже внутри
	ОбработкаИзмененийКонфигурацийВызовСервера.ЗаписатьНовыеДанныеПоРегиструИзменений(Сценарий,Ключ,ДанныеРассчитанныхИзменений);
	
	// запишем проблемы, которые были
	ОбработкаИзмененийКонфигурацийВызовСервера.ЗаписатьЕслиЕстьПроблемыПоРегиструСравнения(Сценарий,Ключ,ДанныеИсходныеИзменения);
	
КонецПроцедуры

Функция РассчитатьПланируемуюВставкуПоКлючу(ДанныеИсходныеИзменения,ТекстНовыйФайл,Сценарий,Ключ,мНастройки=Неопределено) Экспорт
	
	КешСтрокДляСравнения = Новый Соответствие;

	Если НЕ мНастройки=Неопределено Тогда
		Если мНастройки.Свойство("КешСтрокДляСравнения") Тогда
			КешСтрокДляСравнения = мНастройки.КешСтрокДляСравнения;
		КонецЕсли;
	КонецЕсли;
	
	МассивНовыйТекст = Новый Массив;
	МассивСтрок = СтрРазделить(ТекстНовыйФайл,Символы.ПС,Истина);
	
	curNameFunc = "";   
	prevNameFunc = "";
	sourceIndex	 = 1;   
	curPosFunc = 0;        
	lenFunc = 0;             
	// нужна чтобы определить начало, длину
	ПоложениеПараметрыФункции = Новый Соответствие();
	Для каждого стр из МассивСтрок Цикл
		_sourceString = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ПолучитьНезависимуюОбработаннуюСтроку(стр,КешСтрокДляСравнения);
		
		мРез = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ЭтоНачалоФункцииПроцедуры(_sourceString,sourceIndex-1,МассивСтрок);
		Если мРез.Result=Истина Тогда
			curNameFunc = мРез.curNameFunc;
			curPosFunc = sourceIndex;                          
			ПараметрыФункции = Новый Структура();                                
			ПараметрыФункции.Вставить("ИмяФункции",НРег(curNameFunc));
			ПараметрыФункции.Вставить("ОтНачалаФайлаПозицияНачалоФункции",sourceIndex);   
			ПараметрыФункции.Вставить("ОтНачалаФайлаПозицияОкончаниеФункции",-1);   
			ПараметрыФункции.Вставить("ИмяПредыдущейФункции",prevNameFunc);
			ПараметрыФункции.Вставить("ДлинаФункции",-1);
			ПоложениеПараметрыФункции.Вставить(НРег(curNameFunc),ПараметрыФункции);
		КонецЕсли;
			
		СтруктураСтроки = Новый Структура;
		СтруктураСтроки.Вставить("ИмяФункции",curNameFunc);
		СтруктураСтроки.Вставить("ИмяПредыдущейФункции",prevNameFunc);
		СтруктураСтроки.Вставить("Ключ",Ключ);
		СтруктураСтроки.Вставить("Длина",1);
		СтруктураСтроки.Вставить("Текст",стр);                               
		СтруктураСтроки.Вставить("ТипИзменений","eq");                            
		СтруктураСтроки.Вставить("ОтНачалаФайла",sourceIndex);
		СтруктураСтроки.Вставить("ОтНачалаФайлаПозицияНачалоФункции",-1);   	
		СтруктураСтроки.Вставить("ОтНачалаФайлаПозицияОкончаниеФункции",-1);  
		СтруктураСтроки.Вставить("ДлинаФункции",-1);
		СтруктураСтроки.Вставить("Проблема","");
		СтруктураСтроки.Вставить("ТипПроблемы",ПредопределенноеЗначение("Перечисление.ТипыПроблем.Порядок"));
		ОтНачалаФункции = sourceIndex-curPosFunc;
		СтруктураСтроки.Вставить("ОтНачалаФункции",?(curNameFunc<>"",ОтНачалаФункции,-1));
		СтруктураСтроки.Вставить("ОтОкончанияФункции",?(curNameFunc="",ОтНачалаФункции,-1));
		СтруктураСтроки.Вставить("ВероятностьУспеха",0);
		СтруктураСтроки.Вставить("UID",Строка(Новый UUID()));
		//СтруктураСтроки.Вставить("ИмяФайлаВтораяКонфигурация",ИмяФайлаВтораяКонфигурация);
		
		МассивНовыйТекст.Добавить(СтруктураСтроки);
		
		Если СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ЭтоКонецФункцииПроцедуры(_sourceString)=Истина Тогда
			prevNameFunc = curNameFunc;
			curPosFunc = sourceIndex;  
			ПараметрыФункции = ПоложениеПараметрыФункции.Получить(НРег(curNameFunc));
			Если НЕ ПараметрыФункции=Неопределено Тогда
				ПараметрыФункции.ОтНачалаФайлаПозицияОкончаниеФункции=sourceIndex-2;
				ПараметрыФункции.ДлинаФункции = ПараметрыФункции.ОтНачалаФайлаПозицияОкончаниеФункции-ПараметрыФункции.ОтНачалаФайлаПозицияНачалоФункции;
			КонецЕсли;
			curNameFunc = "";
		КонецЕсли;  
		
		sourceIndex = sourceIndex+1;
	КонецЦикла;
	
	// проставим длину и окончание функции
	Для каждого стр из МассивНовыйТекст Цикл    
		ПараметрыФункции = ПоложениеПараметрыФункции.Получить(НРег(стр.ИмяФункции));
		Если ПараметрыФункции=Неопределено Тогда
			Продолжить;
		КонецЕсли;	
		стр.ДлинаФункции=ПараметрыФункции.ДлинаФункции;
		стр.ОтНачалаФайлаПозицияОкончаниеФункции=ПараметрыФункции.ОтНачалаФайлаПозицияОкончаниеФункции;
		стр.ОтНачалаФайлаПозицияНачалоФункции=ПараметрыФункции.ОтНачалаФайлаПозицияНачалоФункции;
	КонецЦикла;
	
	// накладываем изменения
	СоотвествиеПозицийФункций = Новый Соответствие();
	Для каждого стр из ДанныеИсходныеИзменения Цикл         
		Если стр.ТипИзменений="eq" Тогда
			Продолжить;
		КонецЕсли;
		ИмяФункции = ?(стр.ИмяФункции<>"",стр.ИмяФункции+" start",стр.ИмяПредыдущейФункции+" end");
		Позиция = ?(стр.ИмяФункции<>"",стр.ОтНачалаФункции,стр.ОтОкончанияФункции);
		СоотвествиеПозицийФункций.Вставить(ИмяФункции+"/"+стр.ТипИзменений+"/"+Позиция,стр);
	КонецЦикла;
	
	СтруктураСтроки = Неопределено;
	
	// сначала вставим всю таблицу
	СоответствиеСтрокНовый = Новый Соответствие();
	Для _counter=0 ПО МассивНовыйТекст.ВГраница() Цикл
		СтруктураСтроки = МассивНовыйТекст[_counter];
		// ключ
		ИмяФункции = ?(СтруктураСтроки.ИмяФункции<>"",СтруктураСтроки.ИмяФункции+" start",СтруктураСтроки.ИмяПредыдущейФункции+" end");
		Позиция = ?(СтруктураСтроки.ИмяФункции<>"",СтруктураСтроки.ОтНачалаФункции,СтруктураСтроки.ОтОкончанияФункции);
		КлючИзменения = ИмяФункции+"/"+Позиция;		
		СоответствиеСтрокНовый.Вставить(КлючИзменения,СтруктураСтроки);
		КлючИзменения = _counter+1;		
		СоответствиеСтрокНовый.Вставить(КлючИзменения,СтруктураСтроки);      
		// вставим тег начала функции
		Если СтруктураСтроки.ИмяФункции<>"" И СтруктураСтроки.ОтНачалаФункции=0 Тогда
			КлючИзменения = СтруктураСтроки.ИмяФункции+" start";
			СоответствиеСтрокНовый.Вставить(КлючИзменения,СтруктураСтроки);
		КонецЕсли;  
		// вставим тег окончания функции
		Если СтруктураСтроки.ИмяФункции<>"" И _counter+1<МассивНовыйТекст.Количество() 
			И (МассивНовыйТекст[_counter+1].ОтНачалаФункции=-1    
			// если функция начинается сразу же за окончанием
			ИЛИ  СтруктураСтроки.ИмяФункции<>МассивНовыйТекст[_counter+1].ИмяФункции И МассивНовыйТекст[_counter+1].ОтНачалаФункции=0) Тогда
			КлючИзменения = СтруктураСтроки.ИмяФункции+" end";             
			СоответствиеСтрокНовый.Вставить(КлючИзменения,СтруктураСтроки);
		КонецЕсли;
	КонецЦикла; 

	// отатки до начала
	КлючИзменения = 0;		
	СоответствиеСтрокНовый.Вставить(КлючИзменения,МассивНовыйТекст[0]);
	
	// остатки за границами
	КлючИзменения = ИмяФункции+"/"+(Позиция+1);		
	СоответствиеСтрокНовый.Вставить(КлючИзменения,СтруктураСтроки);
	КлючИзменения = _counter+1;		
	СоответствиеСтрокНовый.Вставить(КлючИзменения,СтруктураСтроки);
	
	УжеУдаленоВставлено = Новый Соответствие();
	//УжеУдалено = Новый Соответствие();
	
	// теперь ищем удаления    
	Для каждого стр_изм из ДанныеИсходныеИзменения Цикл
		Если НЕ (стр_изм.ТипИзменений="del" ИЛИ стр_изм.ТипИзменений=ПредопределенноеЗначение("Перечисление.ТипыИзменений.Удаление")) Тогда
			Продолжить;
		КонецЕсли;
		ИмяФункции = ?(стр_изм.ИмяФункции<>"",стр_изм.ИмяФункции+" start",стр_изм.ИмяПредыдущейФункции+" end");
		Позиция = ?(стр_изм.ИмяФункции<>"",стр_изм.ОтНачалаФункции,стр_изм.ОтОкончанияФункции);
		КлючИзменения = ИмяФункции+"/"+Позиция;    //TODO: если не попали в позицию даже рядом, то идем от конца функции 
		
		// пустые строки удалять не будем, нет смысла
		Если НЕ ЗначениеЗаполнено(стр_изм.Текст) Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияУдаления = СоответствиеСтрокНовый.Получить(КлючИзменения);
		
		Если ПозицияУдаления=Неопределено Тогда
			стр_изм.Проблема = "Не могу найти точку удаления, нет такой функции/процедуры в приемнике.";
			стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Ошибка");
		Иначе
			
			ПозицияТекста = ПозицияУдаления.ОтНачалаФайла;        
			СмещениеТекста = 0;          
			МассивСтрокУдаления = СтрРазделить(стр_изм.Текст,Символы.ПС,Ложь);       
			// ищем вхождение вверх + верхняя удаляемас трока  
			ТекстЯкоряПеред = ?(ЗначениеЗаполнено(МассивСтрокУдаления[0]),МассивСтрокУдаления[0]+Символы.ПС,"")+стр_изм.ЯкорьПеред;
			ПозПеред = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(ТекстЯкоряПеред,МассивСтрок,ПозицияТекста+1,Истина,КешСтрокДляСравнения);
			// ищем вхождение вниз + последняя удаляемая строк                
			ТекстЯкоряПосле = ?(ЗначениеЗаполнено(МассивСтрокУдаления[МассивСтрокУдаления.ВГраница()]),МассивСтрокУдаления[МассивСтрокУдаления.ВГраница()]+Символы.ПС,"")+стр_изм.ЯкорьПосле;
			ПозПосле = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(ТекстЯкоряПосле,МассивСтрок,ПозицияТекста-1,Ложь,КешСтрокДляСравнения);
			
			//// если мы не угадали с позицией, тогда давайте скан ввер от конца функции и вниз от начала
			//// ищем полное совпадение ключей
			//Если ПозПеред.Probability=0 И ПозПосле.Probability=0 Тогда	
			//	ПозНач = СоответствиеСтрокНовый.Получить(стр_изм.ИмяФункции+" start");	
			//	ПозПосле = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(ТекстЯкоряПосле,МассивСтрок,ПозНач.ОтНачалаФайла,Ложь,КешСтрокДляСравнения);
			//	ПозОкон = СоответствиеСтрокНовый.Получить(стр_изм.ИмяФункции+" end");	
			//	ПозПеред = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(ТекстЯкоряПеред,МассивСтрок,ПозОкон.ОтНачалаФайла,Истина,КешСтрокДляСравнения);
			//КонецЕсли;
			
			// второй проход, если не смогли запозиционироваться сходу
			Если НЕ ПозПеред.InsertPoint=-1 И ПозПосле.InsertPoint=-1 Тогда
				ПозПосле = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(ТекстЯкоряПосле,МассивСтрок,ПозПеред.InsertPoint,Ложь,КешСтрокДляСравнения);
			ИначеЕсли ПозПеред.InsertPoint=-1 И НЕ ПозПосле.InsertPoint=-1 Тогда
				ПозПеред = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(ТекстЯкоряПеред,МассивСтрок,ПозПосле.InsertPoint,Истина,КешСтрокДляСравнения);
			КонецЕсли;
			
			Если ПозПеред.Probability=0 И ПозПосле.Probability=0 Тогда
				стр_изм.Проблема = "Не совпадают ключи до и после, возможно данный блок переписали.";
				стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Ошибка");
			Иначе                        
				Probability = ?(ПозПеред.Probability=0,0.01,ПозПеред.Probability)*?(ПозПосле.Probability=0,0.01,ПозПосле.Probability); 
				lines = СтрРазделить(стр_изм.Текст,Символы.ПС,Истина); // нужны удаляемые поля
				delItem=0;
				
				// движемся сверху вниз
				Если НЕ ПозПеред.InsertPoint=-1 И ПозПосле.InsertPoint=-1 Тогда
					
					// предупреждение 
					стр_изм.Проблема = "Позиция удаления найдена по одному верхнему якорю.";
					стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Предупреждение");
					
					delCount = ПозПеред.InsertPoint;  
					delItem = 0;
					
					Пока delCount<МассивСтрок.Количество() И delCount>=ПозПеред.InsertPoint И delItem<lines.Количество() Цикл
						
						КлючИзменения = delCount;	
						ПозицияУдаления = СоответствиеСтрокНовый.Получить(КлючИзменения);
						_string = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ПолучитьНезависимуюОбработаннуюСтроку(ПозицияУдаления.Текст,КешСтрокДляСравнения);
						_tmp = 	СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ПолучитьНезависимуюОбработаннуюСтроку(lines[delItem],КешСтрокДляСравнения);
						Если _string=_tmp Тогда
							//УжеБылоУдалено = УжеУдалено.Получить(delCount);
							УжеБылоУдалено = УжеУдаленоВставлено.Получить(delCount);
							Если НЕ УжеБылоУдалено=Истина Тогда								
								ПозицияУдаления.Текст = "// "+ПозицияУдаления.Текст;
								ПозицияУдаления.ТипИзменений = стр_изм.ТипИзменений;    
								ПозицияУдаления.ВероятностьУспеха = Probability;
								ПозицияУдаления.UID = стр_изм.UID;
								//УжеУдалено.Вставить(delCount,Истина);	
								УжеУдаленоВставлено.Вставить(delCount,ПозицияУдаления);	
							КонецЕсли;
							delItem=delItem+1;
						КонецЕсли;                                   
						// если прервались, то прекращаем
						Если _string<>_tmp И delItem<lines.ВГраница() И _string<>"" Тогда
							стр_изм.Проблема = "Не смог найти все строчки для удаления! Обработайте вручную.";
							стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Ошибка");
							Прервать;
						КонецЕсли;
						delCount=delCount+1;          
						
						// если начало функции, то все
						Если СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ЭтоКонецФункцииПроцедуры(_string)=Истина Тогда
							Прервать;
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;                                                           
				
				// движемся снизу вверх
				Если ПозПеред.InsertPoint=-1 И НЕ ПозПосле.InsertPoint=-1 Тогда

					// предупреждение 
					стр_изм.Проблема = "Позиция удаления найдена по одному нижнему якорю.";
					стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Предупреждение");
					
					delCount = ПозПосле.InsertPoint;  
					delItem=lines.ВГраница();
					
					Пока delCount>0 И delCount<=ПозПосле.InsertPoint И delItem>=0 Цикл
						
						КлючИзменения = delCount;	
						ПозицияУдаления = СоответствиеСтрокНовый.Получить(КлючИзменения);
						_string = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ПолучитьНезависимуюОбработаннуюСтроку(ПозицияУдаления.Текст,КешСтрокДляСравнения);
						_tmp = 	СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ПолучитьНезависимуюОбработаннуюСтроку(lines[delItem],КешСтрокДляСравнения);
						Если _string=_tmp Тогда
							//УжеБылоУдалено = УжеУдалено.Получить(delCount);
							УжеБылоУдалено = УжеУдаленоВставлено.Получить(delCount);
							Если НЕ УжеБылоУдалено=Истина Тогда								
								ПозицияУдаления.Текст = "// "+ПозицияУдаления.Текст;
								ПозицияУдаления.ТипИзменений = стр_изм.ТипИзменений;    
								ПозицияУдаления.ВероятностьУспеха = Probability;
								ПозицияУдаления.UID = стр_изм.UID;
								//УжеУдалено.Вставить(delCount,Истина);	
								УжеУдаленоВставлено.Вставить(delCount,ПозицияУдаления);	
							КонецЕсли;
							delItem=delItem-1;
						КонецЕсли;                                   
						// если прервались, то прекращаем
						Если _string<>_tmp И delItem<lines.ВГраница() И _string<>"" Тогда
							стр_изм.Проблема = "Не смог найти все строчки для удаления! Обработайте вручную.";
							стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Ошибка");
							Прервать;
						КонецЕсли;
						delCount=delCount-1;          
						
						// если начало функции, то все
						Если СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ЭтоНачалоФункцииПроцедуры(_string,delCount,МассивСтрок).Result=Истина Тогда
							Прервать;
						КонецЕсли;
						
					КонецЦикла;
				КонецЕсли;                                                           
				
				// движемся между)
				Если НЕ ПозПеред.InsertPoint=-1 И НЕ ПозПосле.InsertPoint=1 И delItem<lines.Количество() Тогда
					delCount = ПозПеред.InsertPoint;
					Пока delCount<=ПозПосле.InsertPoint И ПозПосле.InsertPoint>=ПозПеред.InsertPoint И delItem<lines.Количество() Цикл
						КлючИзменения = delCount;	
						ПозицияУдаления = СоответствиеСтрокНовый.Получить(КлючИзменения);
						_string = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ПолучитьНезависимуюОбработаннуюСтроку(ПозицияУдаления.Текст,КешСтрокДляСравнения);
						_tmp = 	СравнениеТекстBSLУпрощенныйDiffКлиентСервер.ПолучитьНезависимуюОбработаннуюСтроку(lines[delItem],КешСтрокДляСравнения);
						Если _string=_tmp Тогда
							//УжеБылоУдалено = УжеУдалено.Получить(delCount);
							УжеБылоУдалено = УжеУдаленоВставлено.Получить(delCount);
							Если НЕ УжеБылоУдалено=Истина Тогда								
								ПозицияУдаления.Текст = "// "+ПозицияУдаления.Текст;
								ПозицияУдаления.ТипИзменений = стр_изм.ТипИзменений;    
								ПозицияУдаления.ВероятностьУспеха = Probability;
								ПозицияУдаления.UID = стр_изм.UID;
								//УжеУдалено.Вставить(delCount,Истина);	
								УжеУдаленоВставлено.Вставить(delCount,ПозицияУдаления);	
							КонецЕсли;
							delItem=delItem+1;
						КонецЕсли;
						delCount=delCount+1;
					КонецЦикла;
					Если delItem<lines.Количество() Тогда
						стр_изм.Проблема = "Не смог найти все строчки для удаления! Обработайте вручную.";
						стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Ошибка");
					КонецЕсли;
					
				КонецЕсли;                                                           
				
			КонецЕсли; 		
	
		КонецЕсли;
		
	КонецЦикла;                 
	
	//УжеВставлено = Новый Соответствие();
	
	// вставки
	Для каждого стр_изм из ДанныеИсходныеИзменения Цикл
		Если НЕ (стр_изм.ТипИзменений="ins" ИЛИ стр_изм.ТипИзменений=ПредопределенноеЗначение("Перечисление.ТипыИзменений.Вставка")) Тогда
			Продолжить;              
		КонецЕсли;       

		ИмяФункции = ?(стр_изм.ИмяФункции<>"",стр_изм.ИмяФункции+" start",стр_изм.ИмяПредыдущейФункции+" end");
		Позиция = ?(стр_изм.ИмяФункции<>"",стр_изм.ОтНачалаФункции,стр_изм.ОтОкончанияФункции);
		КлючИзменения = ИмяФункции+"/"+Позиция;
		
		ПозицияВставки = СоответствиеСтрокНовый.Получить(КлючИзменения);

		// 1. Если вставка в самом начале, то вставим в самое начало
		// 2. Если мы вставляем поле функции и такой позиции найти не можем, то вставим
		// строго в конце файла
		Если ПозицияВставки=Неопределено И стр_изм.ИмяФункции="" И стр_изм.ИмяПредыдущейФункции="" Тогда
			ПозицияВставки = СоответствиеСтрокНовый.Получить(0);
			стр_изм.Проблема = "Вставляю в начало файла!";
			стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Предупреждение");
		ИначеЕсли ПозицияВставки=Неопределено И стр_изм.ИмяФункции="" Тогда
			ПозицияВставки = СоответствиеСтрокНовый.Получить(МассивСтрок.Количество());
			стр_изм.Проблема = "Вставляю в конце файла!";
			стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Предупреждение");
		ИначеЕсли ПозицияВставки=Неопределено И стр_изм.ИмяФункции<>"" Тогда // функция меньше чем в предыдущей, идем с конца
			//пробуем конце функции взять
			КлючИзменения = стр_изм.ИмяФункции+" end";
			ПозицияВставки = СоответствиеСтрокНовый.Получить(КлючИзменения);
		КонецЕсли;
		
		Если ПозицияВставки=Неопределено Тогда    
			стр_изм.Проблема = "Не могу найти точку вставки, нет такой функции/процедуры в приемнике.";
			стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Ошибка");
		Иначе
			
			ПозицияТекста = ПозицияВставки.ОтНачалаФайла;        
			СмещениеТекста = 0;    
			//TODO: если нашли одну строку, то это плохо, надо пытаться еще
			//до конца функции и выбрать лучший вариант
			//вообще скользить
			ПозПеред = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(стр_изм.ЯкорьПеред,МассивСтрок,ПозицияТекста,Истина,КешСтрокДляСравнения);
			ПозПосле = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(стр_изм.ЯкорьПосле,МассивСтрок,ПозицияТекста-1,Ложь,КешСтрокДляСравнения);
			
	
			// возможно мы промахнулись достаточно сильно, поэтому поищем ближайшее совпадение скольжением вверх и вниз
			// ключ должен совпадать с обоих сторон в этом случае
			// или только одна сторона, но маленькая вероятность
			Если (ПозПеред.Probability=0 И ПозПосле.Probability=0)
				//ИЛИ (ПозПеред.Probability=0 И ПозПосле.Probability<=0.5) 
				//ИЛИ (ПозПеред.Probability<=0.5 И ПозПосле.Probability=0) 
				Тогда	            
				мРез = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиСкольжениемПоТексту(
				стр_изм.ЯкорьПеред,стр_изм.ЯкорьПосле,МассивСтрок,ПозицияТекста,КешСтрокДляСравнения,
				ПозицияВставки.ОтНачалаФайлаПозицияНачалоФункции,ПозицияВставки.ОтНачалаФайлаПозицияОкончаниеФункции);	           
				ПозПеред = мРез.ПозПеред;
				ПозПосле = мРез.ПозПосле;                                 
			КонецЕсли;        
			
			// возможно позиция съехала и одна из границ не нашлась 
			// более мягкий способ в отличии от скольжения
			Если (ПозПеред.Probability=0 И ПозПосле.Probability=0) Тогда          
				// сначала попробуем с низу функции пройтись
				ПозицияТекста=ПозицияВставки.ОтНачалаФайлаПозицияОкончаниеФункции;	
				Если ПозицияТекста>0 Тогда       
					ПозПеред = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(стр_изм.ЯкорьПеред,МассивСтрок,ПозицияТекста,Истина,КешСтрокДляСравнения,2);
				Конецесли;
				// попробуем двигаться тогда с верху
				Если ПозПеред.Probability=0 Тогда   
					ПозицияТекста=ПозицияВставки.ОтНачалаФайлаПозицияНачалоФункции;	
					Если ПозицияТекста>0 Тогда
						ПозПосле = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(стр_изм.ЯкорьПосле,МассивСтрок,ПозицияТекста,Ложь,КешСтрокДляСравнения,2);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			
			Если ПозПеред.Probability=0 И ПозПосле.Probability=0 Тогда
				стр_изм.Проблема = "Не совпадают ключи до и после, возможно данный блок переписали.";
				стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Ошибка");
			Иначе      
				
				// второй проход, если не смогли запозиционироваться сходу
				Если НЕ ПозПеред.InsertPoint=-1 И ПозПосле.InsertPoint=-1 Тогда
					ПозПосле = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(стр_изм.ЯкорьПосле,МассивСтрок,ПозПеред.InsertPoint,Ложь,КешСтрокДляСравнения);
				ИначеЕсли ПозПеред.InsertPoint=-1 И НЕ ПозПосле.InsertPoint=-1 Тогда
					ПозПеред = СравнениеТекстBSLУпрощенныйDiffКлиентСервер.НайтиПозициюПоКлючу(стр_изм.ЯкорьПеред,МассивСтрок,ПозПосле.InsertPoint,Истина,КешСтрокДляСравнения);
				КонецЕсли;    			
				
				Если НЕ ПозПеред.InsertPoint=-1 И ПозПосле.InsertPoint=-1 Тогда
					// предупреждение 
					стр_изм.Проблема = "Позиция вставки найдена по одному верхнему якорю.";
					стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Предупреждение");
				ИначеЕсли ПозПеред.InsertPoint=-1 И НЕ ПозПосле.InsertPoint=-1 Тогда
					// предупреждение 
					стр_изм.Проблема = "Позиция вставки найдена по одному нижнему якорю.";
					стр_изм.ТипПроблемы = ПредопределенноеЗначение("Перечисление.ТипыПроблем.Предупреждение");
				КонецЕсли;
				
				Probability = ?(ПозПеред.Probability=0,0.01,ПозПеред.Probability)*?(ПозПосле.Probability=0,0.01,ПозПосле.Probability); 
				
				Если ПозПеред.Probability>ПозПосле.Probability Тогда
					ПозицияВставкиТекста = ПозПеред.InsertPoint+1; 
				Иначе
					ПозицияВставкиТекста = ПозПосле.InsertPoint;
				КонецЕсли;
				
				Если ПозицияВставкиТекста>=МассивНовыйТекст.Количество() Тогда
					ПозицияВставкиТекста=МассивНовыйТекст.Количество()-1;
				КонецЕсли;      
				
				КлючИзменения = ПозицияВставкиТекста;		
				УточненнаяПозицияВставки = СоответствиеСтрокНовый.Получить(КлючИзменения);
				
				// если мы уже вставили, то все другие вставки должны быть после
				//УжеБылаВставка = УжеВставлено.Получить(УточненнаяПозицияВставки.ОтНачалаФайла); 
				//УжеБылаВставка = УжеУдаленоВставлено.Получить(УточненнаяПозицияВставки.ОтНачалаФайла); 
				//Если УжеБылаВставка<>Неопределено Тогда
				//	Индекс = МассивНовыйТекст.Найти(УжеБылаВставка)+1;
				//	Если Индекс>МассивНовыйТекст.Количество()-1 Тогда
				//		Индекс=МассивНовыйТекст.Количество()-1;
				//	КонецЕсли;
				//	УточненнаяПозицияВставки = МассивНовыйТекст[Индекс];
				//КонецЕсли;
				
				//textLines = СтрРазделить("//>>> auto_insert_start "+Символы.ПС+стр_изм.Текст+Символы.ПС+"//<<< auto_insert_end ",Символы.ПС,Истина);
				textLines = СтрРазделить(стр_изм.Текст,Символы.ПС,Истина);
				Индекс = МассивНовыйТекст.Найти(УточненнаяПозицияВставки); // следующий
				ш=0;
				Для каждого string из textLines Цикл     
					
					СтруктураСтроки = Новый Структура;
					СтруктураСтроки.Вставить("ИмяФункции",ПозицияВставки.ИмяФункции);
					СтруктураСтроки.Вставить("ИмяПредыдущейФункции",ПозицияВставки.ИмяПредыдущейФункции);
					СтруктураСтроки.Вставить("Ключ",ПозицияВставки.Ключ);
					СтруктураСтроки.Вставить("Длина",1);
					СтруктураСтроки.Вставить("Текст",string);
					СтруктураСтроки.Вставить("ТипИзменений","ins");
					//СтруктураСтроки.Вставить("ТипИзменений",ПредопределенноеЗначение("Перечисление.ТипыИзменений.Вставка"));
					СтруктураСтроки.Вставить("Проблема","");
					СтруктураСтроки.Вставить("ТипПроблемы",ПредопределенноеЗначение("Перечисление.ТипыПроблем.Порядок"));
					СтруктураСтроки.Вставить("ОтНачалаФайла",-1);
					СтруктураСтроки.Вставить("ОтНачалаФункции",-1);
					СтруктураСтроки.Вставить("ОтОкончанияФункции",-1);
					СтруктураСтроки.Вставить("ВероятностьУспеха",Probability);
					СтруктураСтроки.Вставить("UID",стр_изм.UID);
					
					МассивНовыйТекст.Вставить(Индекс+ш,СтруктураСтроки);
					ш=ш+1;
					
					//УжеВставлено.Вставить(УточненнаяПозицияВставки.ОтНачалаФайла,СтруктураСтроки);
					УжеУдаленоВставлено.Вставить(УточненнаяПозицияВставки.ОтНачалаФайла,СтруктураСтроки);

				КонецЦикла;
				
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;      
	
	// просчитаем вставку от начала файла и начала функции, т.к. предыдущие не верны
	// вставка делается над текущей строкой, которая на равенство
	ПозицияПредыдущаяОтНачалаФайла=1;
	ПозицияПредыдущаяОтНачалаФункции=1;
	ПозицияПредыдущаяОтОкончанияФункции=1;
	Для каждого стр из МассивНовыйТекст Цикл
		Если стр.ТипИзменений="ins" ИЛИ стр.ТипИзменений=ПредопределенноеЗначение("Перечисление.ТипыИзменений.Вставка") Тогда
			стр.ОтНачалаФайла = ПозицияПредыдущаяОтНачалаФайла+1;
			Если ПозицияПредыдущаяОтНачалаФункции<>-1 Тогда
				стр.ОтНачалаФункции = ПозицияПредыдущаяОтНачалаФункции+1;
			КонецЕсли;                                     
			Если ПозицияПредыдущаяОтОкончанияФункции<>-1 Тогда
				стр.ОтОкончанияФункции = ПозицияПредыдущаяОтОкончанияФункции+1;
			КонецЕсли;
		Иначе
			ПозицияПредыдущаяОтНачалаФайла = стр.ОтНачалаФайла;   
			ПозицияПредыдущаяОтНачалаФункции = стр.ОтНачалаФункции;   
			ПозицияПредыдущаяОтОкончанияФункции = стр.ОтОкончанияФункции;   
		КонецЕсли;
	КонецЦикла;
	
	// сворачиваем                          
	МассивСтрокКУдалениюПослеСвертки = Новый Массив;
	СворачиваемаяСтрока = Неопределено;
	Для каждого стр из МассивНовыйТекст Цикл
		
		Если СворачиваемаяСтрока=Неопределено Тогда
			СворачиваемаяСтрока = стр;
		ИначеЕсли СворачиваемаяСтрока.ТипИзменений=стр.ТипИзменений 
			Тогда    
			СворачиваемаяСтрока.Текст = СворачиваемаяСтрока.Текст+Символы.ПС+стр.Текст;
			СворачиваемаяСтрока.Длина = СворачиваемаяСтрока.Длина+стр.Длина;
			МассивСтрокКУдалениюПослеСвертки.Добавить(МассивНовыйТекст.Найти(стр));
		Иначе
			СворачиваемаяСтрока = стр;
		КонецЕсли;
		
	КонецЦикла;
	
	Для ш=0 По МассивСтрокКУдалениюПослеСвертки.ВГраница() Цикл
		стр = МассивСтрокКУдалениюПослеСвертки[МассивСтрокКУдалениюПослеСвертки.ВГраница()-ш];
		МассивНовыйТекст.Удалить(стр);
	КонецЦикла;                  
	
	мРез = ОбработкаИзмененийКонфигурацийВызовСервера.ПолучитьИнформациюПоДобавлениюКомментариев();
	МассивСтрокКУдалению = Новый Массив;
	
	// втсавляем теги удаления и вставки      
	Если мРез.ДобавлятьКомментарииПриВставке=Истина ИЛИ мРез.ДобавлятьКомментарииПриУдалении=Истина Тогда
		Для каждого стр из МассивНовыйТекст Цикл
			Если мРез.ДобавлятьКомментарииПриВставке=Истина И (стр.ТипИзменений="ins" ИЛИ стр.ТипИзменений=ПредопределенноеЗначение("Перечисление.ТипыИзменений.Вставка")) Тогда                                                                            
				стр.Текст = "//"+мРез.ШаблоНачалаВставки+Символы.ПС+стр.Текст+Символы.ПС+"//"+мРез.ШаблоОкончанияВставки;
				стр.Длина = стр.Длина+2;
			ИначеЕсли мРез.ДобавлятьКомментарииПриУдалении=Истина И ( стр.ТипИзменений="del"  ИЛИ стр.ТипИзменений=ПредопределенноеЗначение("Перечисление.ТипыИзменений.Удаление")) Тогда
				стр.Текст = "//"+мРез.ШаблоНачалаУдаления+Символы.ПС+стр.Текст+Символы.ПС+"//"+мРез.ШаблоОкончанияУдаления;
				стр.Длина = стр.Длина+2;
			КонецЕсли;
			Если мРез.УдалятьУдаленныеСтрокиИзИтоговогоФайла=Истина Тогда
				МассивСтрокКУдалению.Добавить(МассивНовыйТекст.Найти(стр));
			КонецЕсли;
		КонецЦикла;   
	КонецЕсли;           
	
	// удаляем строки удаления
	Если мРез.УдалятьУдаленныеСтрокиИзИтоговогоФайла=Истина Тогда
		Для ш=0 ПО МассивСтрокКУдалению.Количество()-1 Цикл
			МассивНовыйТекст.Удалить(МассивСтрокКУдалению.ВГраница()-ш);	
		КонецЦикла;
	КонецЕсли;
	
	Возврат МассивНовыйТекст;	
	
КонецФункции

