
// Функция - Сравнить тексты файлов
//
// Параметры:
//  ТекстИсходныйФайл	 - строка, текст - исходный файл для сравнения
//  ТекстПолучательФайл	 - 	строка, текст - сравниваемый файл
//  мНастройки			 - структура	 - настройки  (ГлубинаЯкоря, ГлубинаПоиска, МаксимальнаяДистанция, КешСтрокДляСравнения) 
// 
// Возвращаемое значение:
//  Структура - ts (время),_source (массив источник),_dest (массив приемник),_stateList (массив изменений)
//
Функция СравнитьТекстыФайлов(ТекстИсходныйФайл,ТекстПолучательФайл,мНастройки=Неопределено) Экспорт

	// тут пошло сравнение
	// удалить
		
	time = 0;
	мРез = Неопределено;   
	
	// укажем параметры, если были пустые
	Если мНастройки=Неопределено Тогда
		мНастройки = Новый Структура();	
	КонецЕсли;
		
	Если НЕ мНастройки.Свойство("КешСтрокДляСравнения") Тогда
		мНастройки.Вставить("КешСтрокДляСравнения",Новый Соответствие());
	КонецЕсли;
	
	Если НЕ мНастройки.Свойство("ГлубинаЯкоря") Тогда
		мНастройки.Вставить("ГлубинаЯкоря",4);
	КонецЕсли;     
	
	Если НЕ мНастройки.Свойство("ГлубинаПоиска") Тогда
		мНастройки.Вставить("ГлубинаПоиска",5);
	КонецЕсли;     	
	
	
	Если НЕ мНастройки.Свойство("МаксимальнаяДистанция") Тогда
		мНастройки.Вставить("МаксимальнаяДистанция",1000);                                         
	КонецЕсли;
	
	
	Попытка        
		
		// массив разностей
		sLF = СтрРазделить(Символы.ПС+ТекстИсходныйФайл,Символы.ПС,Истина);     // добавим смещение, чтобы вместо 0 был 1
		dLF = СтрРазделить(Символы.ПС+ТекстПолучательФайл,Символы.ПС,Истина);   // добавим смещение, чтобы вместо 0 был 1

		// найдем начало и окончание функций
		sRes = НайтиНачалоОкончаниеПроцедурФункций(sLF);
		dRes = НайтиНачалоОкончаниеПроцедурФункций(dLF);    
		
		СинхронизироватьПорядокФнукцийЕслиТребуется(sRes,dRes,sLF,dLF);
		
		мНастройки.Вставить("dfunPos",dRes.funPos);
		мНастройки.Вставить("sfunPos",sRes.funPos); 			
		
		мРез = _ProcessDiff(sLF,dLF,"fast",мНастройки);                      
	Исключение
		Сообщить(ОписаниеОшибки());
	КонецПопытки;
	
	Возврат мРез;
	
КонецФункции

Функция _ProcessDiff(_source,_dest,_level,мНастройки) Экспорт
   
	dt = ТекущаяДата();
	_matchList = новый Массив;
	
	dcount = _dest.Count();
	scount = _source.Count();	
	
	Если ((dcount > 0)И(scount > 0)) Тогда
		_stateList = новый Массив;
		СравнитьПоДиапазону(1,1,_stateList,_level,_source,_dest,мНастройки);
	КонецЕсли;
	
	ts = ТекущаяДата() - dt; 
	
	Возврат новый Структура("ts,_source,_dest,_stateList",ts,_source,_dest,_stateList);
	
КонецФункции

Процедура СравнитьПоДиапазону(sourceStart,destStart,_stateList,_level,_source,_dest,мНастройки)
	
	КешСтрокДляСравнения = мНастройки.КешСтрокДляСравнения;
	ГлубинаЯкоря = мНастройки.ГлубинаЯкоря;
	ГлубинаПоиска = мНастройки.ГлубинаПоиска;
	МаксимальнаяДистанция = мНастройки.МаксимальнаяДистанция;
	sourceIndex = sourceStart;
	destIndex = destStart;   
	countIndex = 0;    
	curNameFunc = "";  
	prevNameFunc = "";  
	curPosFunc = 0;
	curPosEndFunc = 0;
	curStruct = Новый Структура("index,state,start,lines,funcName,prevNameFunc,funcRelStartPos,funcRelEndPos,anhornBefore,anhornAfter");
	//// для позиционирования по функциям
	//dfunPos = Новый Соответствие;
	//Если мНастройки.Свойство("dfunPos") Тогда
	//	dfunPos = мНастройки.dfunPos;
	//КонецЕсли;    
	//old_destIndex = 0;
	
	Пока destIndex<_dest.Количество() ИЛИ sourceIndex<_source.Количество() Цикл
		
		Если sourceIndex<_source.Количество() Тогда  
			_sourceString = ПолучитьНезависимуюОбработаннуюСтроку(_source[sourceIndex],КешСтрокДляСравнения);              
		Иначе                                                                           
			_sourceString = Неопределено;
		КонецЕсли;            
		
		// имя функции    
		мФун = ЭтоНачалоФункцииПроцедуры(_sourceString,sourceIndex,_source);
		Если мФун.Result=Истина Тогда
			curNameFunc = мФун.curNameFunc;
			curPosFunc = sourceIndex; // строка начинается с 1 
		КонецЕсли;  

		Если destIndex<_dest.Количество() Тогда  
			_destString = ПолучитьНезависимуюОбработаннуюСтроку(_dest[destIndex],КешСтрокДляСравнения);
		Иначе                                                                           
			_destString = Неопределено;
		КонецЕсли; 	         
		
		// сохраняем позицию до изменения счетчика
		Если ЭтоКонецФункцииПроцедуры(_sourceString) Тогда
			curPosEndFunc = sourceIndex;
		КонецЕсли;  
		
		Если _sourceString=_destString Тогда
			// не пишем равенство        
			Если curStruct.state="eq" Тогда                                          
				Если НЕ _sourceString=Неопределено Тогда
					curStruct.lines.Добавить(_source[sourceIndex]);
				КонецЕсли;
			Иначе         
				anhornBefore = ПолучитьAnhornBefore(_source,sourceIndex,КешСтрокДляСравнения,ГлубинаЯкоря);
				anhornAfter = ПолучитьAnhornAfter(_source,sourceIndex,КешСтрокДляСравнения,ГлубинаЯкоря);   
				lines = Новый Массив;                   
				Если НЕ _sourceString=Неопределено Тогда
					lines.Добавить(_source[sourceIndex]);
				КонецЕсли;
				curStruct = Новый Структура("index,state,start,dist,lines,funcName,prevNameFunc,funcRelStartPos,funcRelEndPos,anhornBefore,anhornAfter",
										countIndex,"eq",sourceIndex,1,lines,curNameFunc,prevNameFunc,-1,-1,anhornBefore,anhornAfter);
				_stateList.Добавить(curStruct);
			КонецЕсли;
			sourceIndex = sourceIndex +1;
			destIndex = destIndex +1;
		Иначе                 
			// если первая закончилась, то все     
			Если  sourceIndex<_source.Количество() Тогда    
				// если пробел, тогда просто удаляем
				Если НЕ ЗначениеЗаполнено(_sourceString) И ЗначениеЗаполнено(_destString) Тогда
					мРез=Неопределено;
				ИначеЕсли _destString=Неопределено Тогда
					мРез=Неопределено;
				Иначе
					мРез = НайтиВхождение(_sourceString,sourceIndex,_source,destIndex,_dest,мНастройки,ГлубинаПоиска,МаксимальнаяДистанция);
				КонецЕсли;
				Если мРез=Неопределено ИЛИ  мРез.status="err" Тогда   
					// добавим в пердыдущее удаление
					Если curStruct.state="del" И curStruct.start+curStruct.dist=sourceIndex И curStruct.funcName=curNameFunc Тогда
						curStruct.dist=curStruct.dist+1;
						anhornAfter = ПолучитьAnhornAfter(_source,sourceIndex,КешСтрокДляСравнения,ГлубинаЯкоря);
						curStruct.anhornAfter = anhornAfter;
						Если НЕ _sourceString=Неопределено Тогда
							curStruct.lines.Добавить(_source[sourceIndex])
						КонецЕсли;
					Иначе                                                                  
						funcRelStartPos = ?(curNameFunc="",-1,sourceIndex-curPosFunc);
						funcRelEndPos = ?(curNameFunc="",sourceIndex-curPosEndFunc,-1);
						anhornBefore = ПолучитьAnhornBefore(_source,sourceIndex,КешСтрокДляСравнения,ГлубинаЯкоря);
						anhornAfter = ПолучитьAnhornAfter(_source,sourceIndex,КешСтрокДляСравнения,ГлубинаЯкоря);
						lines = Новый Массив;
						Если НЕ _sourceString=Неопределено Тогда
							lines.Добавить(_source[sourceIndex])
						КонецЕсли;
						curStruct = Новый Структура("index,state,start,dist,lines,funcName,prevNameFunc,funcRelStartPos,funcRelEndPos,anhornBefore,anhornAfter",
											countIndex,"del",sourceIndex,1,lines,curNameFunc,prevNameFunc,funcRelStartPos,funcRelEndPos,anhornBefore,anhornAfter);
						_stateList.Добавить(curStruct);
					КонецЕсли;
					sourceIndex = sourceIndex +1;				
				Иначе   
					funcRelStartPos = ?(curNameFunc="",-1,sourceIndex-curPosFunc);
					funcRelEndPos = ?(curNameFunc="",sourceIndex-curPosEndFunc,-1);  
					dist = мРез.end-мРез.start;  
					// вставка выполняется над текущей строкой,
					// поэтому якроь вниз (after) содержит текущую строку,
					// а якорь вверх (before) берет предыдущую строку      
					// внутри функции уже есть смещение вверх и вниз на одну строку
					anhornBefore = ПолучитьAnhornBefore(_source,sourceIndex,КешСтрокДляСравнения,ГлубинаЯкоря);
					anhornAfter = ПолучитьAnhornAfter(_source,sourceIndex-1,КешСтрокДляСравнения,ГлубинаЯкоря);
					curStruct = Новый Структура("index,state,start,dist,lines,funcName,prevNameFunc,funcRelStartPos,funcRelEndPos,anhornBefore,anhornAfter",
												countIndex,"ins",sourceIndex,dist,мРез.lines,curNameFunc,prevNameFunc,funcRelStartPos,funcRelEndPos,anhornBefore,anhornAfter);
					_stateList.Добавить(curStruct);
					destIndex = мРез.end;
				КонецЕсли;
			Иначе       
				мРез=Неопределено;                              
				lines = новый Массив;   
				destСтрока = destIndex; 
				Пока destСтрока< _dest.Количество() Цикл
					lines.Добавить(_dest[destСтрока]);
					destСтрока=destСтрока+1;
				КонецЦикла;                   
				dist = lines.Количество();
				funcRelStartPos = ?(curNameFunc="",-1,sourceIndex-curPosFunc);
				funcRelEndPos = ?(curNameFunc="",sourceIndex-curPosEndFunc,-1);
				anhornBefore = ПолучитьAnhornBefore(_source,sourceIndex,КешСтрокДляСравнения,ГлубинаЯкоря);
				anhornAfter = ПолучитьAnhornAfter(_source,sourceIndex-1,КешСтрокДляСравнения,ГлубинаЯкоря);
				curStruct = Новый Структура("index,state,start,dist,lines,funcName,prevNameFunc,funcRelStartPos,funcRelEndPos,anhornBefore,anhornAfter",
											countIndex,"ins",sourceIndex,dist,lines,curNameFunc,prevNameFunc,funcRelStartPos,funcRelEndPos,anhornBefore,anhornAfter);
				_stateList.Добавить(curStruct);
				destIndex = _dest.Количество();
			КонецЕсли;
		КонецЕсли;   
		
		// сбрасываем, если имя текущей функции указано
		Если НЕ curNameFunc="" И ЭтоКонецФункцииПроцедуры(_sourceString) Тогда
			
			//_destOffset = dfunPos.Получить(нРег(curNameFunc));
			//Если НЕ _destOffset=Неопределено Тогда                 
			//	// возвращаем
			//	destIndex = old_destIndex;
			//КонецЕсли;
			
			prevNameFunc = curNameFunc;
			curNameFunc = "";   
			
		КонецЕсли;  
		
		countIndex = countIndex + 1;
	КонецЦикла;
	
КонецПроцедуры  

Функция ЭтоНачалоФункцииПроцедуры(_string,_curIndex,_text) Экспорт  
	мРез = Новый Структура("curNameFunc,Result","",Ложь);
	
	//TODO: учесть что может быть закоментироана
	// если первые два слеша, то это комментарий
	Если Лев(_string,2)="//" Тогда
		Возврат мРез;
	КонецЕсли;   

	// проверяем на начало функции
	Если (СтрНайти(_string,"процедура") ИЛИ СтрНайти(_string,"функция")) И СтрНайти(_string,"(") Тогда
		Массив = СтрРазделить(_text[_curIndex]," (",Ложь);
		Если Массив.Количество()>1 И (НРег(Массив[0])="процедура" ИЛИ НРег(Массив[0])="функция") Тогда
			мРез.Result = Истина;
			мРез.curNameFunc = Массив[1];
		КонецЕсли;
	КонецЕсли;
	
	Возврат мРез;	
КонецФункции 

Функция ЭтоКонецФункцииПроцедуры(_string) Экспорт 
	
	//TODO: учесть что может быть закоментироана    
	
	// если первые два слеша, то это комментарий
	Если Лев(_string,2)="//" Тогда
		Возврат Ложь;
	КонецЕсли;           
	
	// проверяем на конец
	Если СтрНайти(_string,"конецпроцедуры") ИЛИ СтрНайти(_string,"конецфункции") Тогда
		Возврат Истина;
	КонецЕсли;  
	
	Возврат Ложь;
КонецФункции

// Получаются строки после текущей строки. Пустые строки игнорируются. Строки хранятся в обратном порядке.
// 
// Пример:
//  .
// /|\
//  +    МассивСтрок = СтрРазделить(Текст,Символы.ПС,Ложь);
//  +
//  +    Для каждого стр из МассивСтрок Цикл
//  +
//  *			Сообщить(стр);
//  
//       КонецЦикла;
//  
// 
//  
Функция ПолучитьAnhornBefore(_text,_startIndex,КешСтрокДляСравнения,level=1) Экспорт
	Якорь = "";                                                  
	CurIndex = _startIndex;
	МассивНайденныхСтрок = Новый Массив;
	// движемся пока не найдем якоря с текстом, равным уровню
	Если CurIndex>_text.Количество() Тогда
		CurIndex=_text.Количество();
	КонецЕсли;
	CurIndex=CurIndex-1;                                          
	Пока CurIndex>0 И МассивНайденныхСтрок.Количество()<level Цикл
		_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[CurIndex],КешСтрокДляСравнения);
		Если ЗначениеЗаполнено(_string) Тогда
			МассивНайденныхСтрок.Добавить(_text[CurIndex]);
		КонецЕсли;
		// имя функции    
		Если ЭтоНачалоФункцииПроцедуры(_string,CurIndex,_text).Result=Истина Тогда
			Прервать;
		КонецЕсли; 	
		// движемся до конца функции или до конца если это не функция
		Если ЭтоКонецФункцииПроцедуры(_string) Тогда
			Прервать;
		КонецЕсли;			
		CurIndex=CurIndex-1;                 
	КонецЦикла;
	Якорь = СтрСоединить(МассивНайденныхСтрок,Символы.ПС);
	Возврат Якорь;
КонецФункции

// Получаются строки после текущей строки. Пустые строки игнорируются.
// 
// Пример:
//
//      МассивСтрок = СтрРазделить(Текст,Символы.ПС,Ложь);
//
//      Для каждого стр из МассивСтрок Цикл
//
//  *			Сообщить(стр);
//  +
//  +     КонецЦикла;
//  +
// \|/
//  !
Функция ПолучитьAnhornAfter(_text,_startIndex,КешСтрокДляСравнения,level=1) Экспорт
	Якорь = "";                                                  
	CurIndex = _startIndex;
	МассивНайденныхСтрок = Новый Массив;
	// движемся пока не найдем якоря с текстом, равным уровню
	CurIndex=CurIndex+1;
	Пока CurIndex<_text.Количество() И МассивНайденныхСтрок.Количество()<level Цикл
		_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[CurIndex],КешСтрокДляСравнения);
		Если ЗначениеЗаполнено(_string) Тогда
			МассивНайденныхСтрок.Добавить(_text[CurIndex]);
		КонецЕсли;   
		// имя функции    
		Если ЭтоНачалоФункцииПроцедуры(_string,CurIndex,_text).Result=Истина Тогда
			Прервать;
		КонецЕсли; 	
		// движемся до конца функции или до конца если это не функция
		Если ЭтоКонецФункцииПроцедуры(_string) Тогда
			Прервать;
		КонецЕсли;			
		CurIndex=CurIndex+1;                 
	КонецЦикла;
	Якорь = СтрСоединить(МассивНайденныхСтрок,Символы.ПС);
	Возврат Якорь;
КонецФункции


Функция НайтиПозициюПоКлючу(_strings, _text,_startIndex,IsBefore,КешСтрокДляСравнения,_levelFilter=0) Экспорт 
	
	InsertPoint = -1;  
	Probability = 0;
	МассивНайденныхСтрок = Новый Массив; // сюда будем писать сколько совпадений
	МассивСтрокКлючей = СтрРазделить(_strings,Символы.ПС,Ложь); // только значимые строки
	CurIndex = _startIndex;
	level = МассивСтрокКлючей.Количество();
	
	// если пустая строка, то это начало файла или конец файла
	// значит с вероятностью 100% можно вставлять или удалять с этой позиции
	Если НЕ ЗначениеЗаполнено(_strings) Тогда
		
		InsertPoint = _startIndex;
		Probability = 1;
		
	ИначеЕсли IsBefore=Истина Тогда
		
		// идем вверх и сравниваем цепочки
		Если CurIndex>=_text.Количество() Тогда
			CurIndex=_text.Количество()-1;
		КонецЕсли;        
		Если CurIndex<_text.Количество()-1 Тогда
			CurIndex=CurIndex+1;       
		КонецЕсли;
		ш=0; // идем сначала вниз строка уже переврнута
		Пока CurIndex>0 И МассивНайденныхСтрок.Количество()<level Цикл
			_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[CurIndex],КешСтрокДляСравнения);
			Если ЗначениеЗаполнено(_string) Тогда
				// проверка на равенство       
				_stringAnhorn = ПолучитьНезависимуюОбработаннуюСтроку(МассивСтрокКлючей[ш],КешСтрокДляСравнения);
				// если последовательность прервалась, то стоп
				Если МассивНайденныхСтрок.Количество()>0 И _string<>_stringAnhorn И МассивНайденныхСтрок.Количество()>=_levelFilter Тогда
					Прервать;
				ИначеЕсли МассивНайденныхСтрок.Количество()>0 И _string<>_stringAnhorn И МассивНайденныхСтрок.Количество()<_levelFilter Тогда                
					// сбрасываем
					МассивНайденныхСтрок.Очистить(); 
					ш=0;
				КонецЕсли;                                    
				// считаем кличество строк совпадающих
				Если _string=_stringAnhorn Тогда
					МассивНайденныхСтрок.Добавить(CurIndex+1); // смещаем относительно нуля на 1
					ш=ш+1;          
				КонецЕсли;                    
				
				// движемся до начала функции
				Если ЭтоНачалоФункцииПроцедуры(_string,CurIndex,_text).Result=Истина Тогда
					// если удаляемая строка сама не является началом функции
					Если _string=_stringAnhorn Тогда
						_stringInd = ш-1;
					Иначе         
						_stringInd = ш;
					КонецЕсли;
					Если ЭтоНачалоФункцииПроцедуры(_stringAnhorn,_stringInd,МассивСтрокКлючей).Result=Ложь Тогда
						Прервать;
					КонецЕсли;
				КонецЕсли;
				
			КонецЕсли;
			CurIndex=CurIndex-1;                 
		КонецЦикла; 	
		
		Если МассивНайденныхСтрок.Количество()>0 И МассивСтрокКлючей.Количество()=1 Тогда
			InsertPoint = МассивНайденныхСтрок[0];
			Probability = МассивНайденныхСтрок.Количество()/МассивСтрокКлючей.Количество();
		ИначеЕсли МассивНайденныхСтрок.Количество()>1 Тогда
			InsertPoint = МассивНайденныхСтрок[0];
			Probability = МассивНайденныхСтрок.Количество()/МассивСтрокКлючей.Количество();
		КонецЕсли;
		
	Иначе     
		
		// идем вниз и сравниваем цепочки     
		Если CurIndex>1 Тогда
			CurIndex=CurIndex-1; 
		КонецЕсли;
		ш=0; // идем сначала вниз
		Пока CurIndex<_text.Количество() И МассивНайденныхСтрок.Количество()<level Цикл
			_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[CurIndex],КешСтрокДляСравнения);
			Если ЗначениеЗаполнено(_string) Тогда
				// проверка на равенство       
				_stringAnhorn = ПолучитьНезависимуюОбработаннуюСтроку(МассивСтрокКлючей[ш],КешСтрокДляСравнения);
				// если последовательность прервалась, то стоп
				Если МассивНайденныхСтрок.Количество()>0 И _string<>_stringAnhorn И МассивНайденныхСтрок.Количество()>=_levelFilter Тогда
					Прервать;
				ИначеЕсли МассивНайденныхСтрок.Количество()>0 И _string<>_stringAnhorn И МассивНайденныхСтрок.Количество()<_levelFilter Тогда                
					// сбрасываем
					МассивНайденныхСтрок.Очистить(); 
					ш=0;
				КонецЕсли;                                    
				// считаем кличество строк совпадающих
				Если _string=_stringAnhorn Тогда
					МассивНайденныхСтрок.Добавить(CurIndex+1); // смещаем относительно нуля на 1
					ш=ш+1;
				КонецЕсли;                  
				
				// движемся до конца функции или до конца если это не функция
				Если ЭтоКонецФункцииПроцедуры(_string) Тогда
					Прервать;
				КонецЕсли;
			КонецЕсли;
			CurIndex=CurIndex+1;                 
		КонецЦикла; 	
		
		Если МассивНайденныхСтрок.Количество()>0 И МассивСтрокКлючей.Количество()=1 Тогда
			InsertPoint = МассивНайденныхСтрок[0];
			Probability = МассивНайденныхСтрок.Количество()/МассивСтрокКлючей.Количество();
		ИначеЕсли МассивНайденныхСтрок.Количество()>1 Тогда
			InsertPoint = МассивНайденныхСтрок[0];
			Probability = МассивНайденныхСтрок.Количество()/МассивСтрокКлючей.Количество();
		КонецЕсли;
		
	КонецЕсли;		
	
	Возврат Новый Структура("InsertPoint,Probability,lineNumbers",InsertPoint,Probability,МассивНайденныхСтрок);
КонецФункции     

Функция НайтиСкольжениемПоТексту(_stringsAnhornBefore,_stringsAnhornAfter, _text,_startIndex,КешСтрокДляСравнения,_startFuncPos,_endFyncPos) Экспорт

	InsertPoint = -1;  
	Probability = 0;
	МассивСтрокКлючейAnhornBefore = СтрРазделить(_stringsAnhornBefore,Символы.ПС,Ложь);  // только значимые строки
	МассивСтрокКлючейAnhornAfter = СтрРазделить(_stringsAnhornAfter,Символы.ПС,Ложь); // только значимые строки
	
	мРез = Новый Структура();
	мРез.Вставить("ПозПеред",Новый  Структура("InsertPoint,Probability,lineNumbers",-1,0,Новый Массив));	
	мРез.Вставить("ПозПосле",Новый Структура("InsertPoint,Probability,lineNumbers",-1,0,Новый Массив));

	МассивСовпадений = Новый Массив;
	
	мПромежРез1 = Неопределено;
	мПромежРез2	= Неопределено;      
	
	Если _endFyncPos=-1 Тогда
		CurIndex = _startIndex; 
	Иначе
		CurIndex = _endFyncPos;         
	КонецЕсли;
	Если CurIndex>=_text.Количество()-1 Тогда
		CurIndex=_text.Количество()-1;
	КонецЕсли;
	
	// движемся вверх          
	Пока CurIndex>0 Цикл  
		
		мПромежРез1 = ПолучитьЗначениеСовпаденияПриСкольжении(МассивСтрокКлючейAnhornBefore,МассивСтрокКлючейAnhornAfter,CurIndex,_text,КешСтрокДляСравнения);
		
		Если мПромежРез1.Probability>0 Тогда
			//прервем, будем считать что нашли
			Прервать;
		КонецЕсли;
		
		_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[CurIndex],КешСтрокДляСравнения);
		
		// если начало функции или конец, то возврат
		Если ЭтоНачалоФункцииПроцедуры(_string,CurIndex,_text).Result=Истина Тогда
			Прервать;
		КонецЕсли;       
		// движемся до конца функции или до конца если это не функция
		Если ЭтоКонецФункцииПроцедуры(_string)=Истина Тогда
			Прервать;
		КонецЕсли;
		
		CurIndex = CurIndex-1;
		
	КонецЦикла;
	
	
	// движемся вниз   
	Если _startFuncPos=-1 Тогда
		CurIndex = _startIndex;
	Иначе
		CurIndex = _startFuncPos;  
	КонецЕсли;
	Если CurIndex>=_text.Количество()-1 Тогда
		CurIndex=_text.Количество()-1;
	КонецЕсли;
	Пока CurIndex<_text.Количество() Цикл
		
		мПромежРез2 = ПолучитьЗначениеСовпаденияПриСкольжении(МассивСтрокКлючейAnhornBefore,МассивСтрокКлючейAnhornAfter,CurIndex,_text,КешСтрокДляСравнения);
		
		Если мПромежРез2.Probability>0 Тогда
			//прервем, будем считать что нашли
			Прервать;
		КонецЕсли;
		
		_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[CurIndex],КешСтрокДляСравнения);
		
		// если начало функции или конец, то возврат
		Если ЭтоНачалоФункцииПроцедуры(_string,CurIndex,_text).Result=Истина Тогда
			Прервать;
		КонецЕсли;       
		// движемся до конца функции или до конца если это не функция
		Если ЭтоКонецФункцииПроцедуры(_string)=Истина Тогда
			Прервать;
		КонецЕсли;
		
		CurIndex = CurIndex+1;
		
	КонецЦикла;
	
	Если мПромежРез1=Неопределено И НЕ мПромежРез2=Неопределено Тогда
		мРез = мПромежРез2;
	ИначеЕсли НЕ мПромежРез1=Неопределено И мПромежРез2=Неопределено Тогда
		мРез = мПромежРез1;
	ИначеЕсли НЕ мПромежРез1=Неопределено И НЕ мПромежРез2=Неопределено Тогда
		Если мПромежРез1.Probability>мПромежРез2.Probability Тогда
			мРез = мПромежРез1;
		Иначе                  
			мРез = мПромежРез2;
		КонецЕсли;
	КонецЕсли;
	
	Возврат мРез;
	
КонецФункции

Функция ПолучитьЗначениеСовпаденияПриСкольжении(МассивСтрокКлючейAnhornBefore,МассивСтрокКлючейAnhornAfter,CurIndex,_text,КешСтрокДляСравнения)    

	МассивНайденныхСтрокAnhornBefore = Новый Массив; // сюда будем писать сколько совпадений
	МассивНайденныхСтрокAnhornAfter = Новый Массив; // сюда будем писать сколько совпадений
	
	СтруктураСовпадения = Новый Структура;
	СтруктураСовпадения.Вставить("Probability",0);    
	ПозПеред = Новый Структура("InsertPoint,Probability,lineNumbers",-1,0,МассивНайденныхСтрокAnhornBefore);
	СтруктураСовпадения.Вставить("ПозПеред",ПозПеред);          
	ПозПосле = Новый Структура("InsertPoint,Probability,lineNumbers",-1,0,МассивНайденныхСтрокAnhornAfter);
	СтруктураСовпадения.Вставить("ПозПосле",ПозПосле); 		          
	
	
	// ключ вверх
	Если CurIndex>_text.Количество()-1 Тогда
		Индекс=_text.Количество()-1;
	Иначе
		Индекс = CurIndex;
	КонецЕсли;
	ш=0;
	Пока ш<МассивСтрокКлючейAnhornBefore.Количество() Цикл                
		
		Если Индекс<0 Тогда
			Прервать;
		КонецЕсли;            
		_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[Индекс],КешСтрокДляСравнения);
		// проверка на равенство       
		_stringAnhorn = ПолучитьНезависимуюОбработаннуюСтроку(МассивСтрокКлючейAnhornBefore[ш],КешСтрокДляСравнения);
		
		Если НЕ ЗначениеЗаполнено(_string) Тогда
			Индекс=Индекс-1;
			Продолжить;                       
		ИначеЕсли _string=_stringAnhorn Тогда
			МассивНайденныхСтрокAnhornBefore.Добавить(Индекс+1);  // учитываем смещение
		ИначеЕсли _string<>_stringAnhorn Тогда
			Прервать;
		КонецЕсли;
		Индекс = Индекс-1;
		ш=ш+1;
		
	КонецЦикла;
	
	// ключ вниз со следующей строчки?
	Индекс = CurIndex+1;
	ш=0;
	Пока ш<МассивСтрокКлючейAnhornAfter.Количество() Цикл                
		
		Если Индекс>_text.Количество()-1 Тогда
			Прервать;
		КонецЕсли;            
		_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[Индекс],КешСтрокДляСравнения);
		// проверка на равенство       
		_stringAnhorn = ПолучитьНезависимуюОбработаннуюСтроку(МассивСтрокКлючейAnhornAfter[ш],КешСтрокДляСравнения);
		
		Если НЕ ЗначениеЗаполнено(_string) Тогда
			Индекс=Индекс+1;
			Продолжить;                       
		ИначеЕсли _string=_stringAnhorn Тогда
			МассивНайденныхСтрокAnhornAfter.Добавить(Индекс+1); // учитываем смещение
		ИначеЕсли _string<>_stringAnhorn Тогда
			Прервать;
		КонецЕсли;  
		Индекс = Индекс+1;
		ш=ш+1;
		
	КонецЦикла;		
	
	// совпадение должно быть двойным
	Если МассивНайденныхСтрокAnhornAfter.Количество()>0 И МассивНайденныхСтрокAnhornBefore.Количество()>0 Тогда
		ПозПеред.Probability = МассивНайденныхСтрокAnhornBefore.Количество()/МассивСтрокКлючейAnhornBefore.Количество();		
		ПозПеред.InsertPoint = МассивНайденныхСтрокAnhornBefore[0];
		ПозПосле.Probability = МассивНайденныхСтрокAnhornAfter.Количество()/МассивСтрокКлючейAnhornAfter.Количество();
		ПозПосле.InsertPoint = МассивНайденныхСтрокAnhornAfter[0];
		Если МассивНайденныхСтрокAnhornAfter.Количество()>1 ИЛИ МассивНайденныхСтрокAnhornBefore.Количество()>1 Тогда
			СтруктураСовпадения.Вставить("Probability",ПозПеред.Probability*ПозПосле.Probability);
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураСовпадения;
	
КонецФункции	

Функция ПолучитьНезависимуюОбработаннуюСтроку(_string,КешСтрокДляСравнения) Экспорт
	Если НЕ ЗначениеЗаполнено(_string) Тогда
		Возврат "";
	КонецЕсли;      
	РезультатОбработки = КешСтрокДляСравнения.Получить(_string);
	Если РезультатОбработки=Неопределено Тогда
		МассивСтрок = СтрРазделить(НРег(СокрЛП(_string))," "+Символы.ПС+Символы.НПП+Символы.Таб+Символы.ПФ,Ложь);
		РезультатОбработки = СтрСоединить(МассивСтрок);
		КешСтрокДляСравнения.Вставить(_string,РезультатОбработки);
	КонецЕсли;
	Возврат РезультатОбработки; 
КонецФункции

Функция НайтиВхождение(_curString,_sourceIndex,_source,_startIndex,_text,мНастройки,ГлубинаПоиска=5,_maxDist=1000)
	
	КешСтрокДляСравнения = мНастройки.КешСтрокДляСравнения;
	мРез = Неопределено;          
	lines = Новый Массив; 
	
	
	_curIndex = _startIndex+1;      // позиция на следующую строку
	_curStringIsFunc = ЭтоНачалоФункцииПроцедуры(_curString,_sourceIndex,_source).Result;
	
	// проверим что, если мы стоим на текущей функции, то пропускаем этот блок 
	// все же потом надо переписать
	ПерваяСтрочкаЭтоФункцияКоторойНетВИсточнике = Ложь;
	_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[_curIndex-1],КешСтрокДляСравнения);
	мФункц = ЭтоНачалоФункцииПроцедуры(_string,_curIndex-1,_text);
	Если мФункц.Result=Истина  Тогда		
		// если этой функций нет в исходном файле, то проматываем ее всю
		Если мНастройки.sfunPos.Получить(НРег(мФункц.curNameFunc))=Неопределено Тогда
			ПерваяСтрочкаЭтоФункцияКоторойНетВИсточнике = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Пока _curIndex<_text.Количество() Цикл       
		
		_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[_curIndex],КешСтрокДляСравнения);
		lines.Добавить(_text[_curIndex-1]);
		
		Если _curString=_string Тогда
			мРез = Новый Структура("status,start,end,lines","ok",_startIndex,_curIndex,lines);
			Прервать;  
		Иначе // тут мы должны проврить, а вот эта строка встречается где-то ниже в первом тексте
			Если _curStringIsFunc=Ложь И ЗначениеЗаполнено(_string) И ЗначениеЗаполнено(_curString) Тогда
				
				// сравнивать будем по наборам строк
				ш=_curIndex-1;
				_stringsTo = Новый Массив; 
				Пока ш<_text.Количество()-1 И ш-_curIndex<ГлубинаПоиска Цикл
					ш=ш+1;
					_tmp = ПолучитьНезависимуюОбработаннуюСтроку(_text[ш],КешСтрокДляСравнения);
					Если НЕ ЗначениеЗаполнено(_tmp) Тогда
						Продолжить;
					Иначе
						_stringsTo.Добавить(_tmp);
					КонецЕсли;	
					
					// ХАК
					// ищем до КонецФункции или КонецПроцедуры
					Если ЭтоКонецФункцииПроцедуры(_tmp)=Истина Тогда
						Прервать;
					КонецЕсли; 
					// ХАК
					// ИЛИ до начала функции
					Если ЭтоНачалоФункцииПроцедуры(_tmp,ш,_text).Result=Истина Тогда
						Прервать;
					КонецЕсли; 					
					
				КонецЦикла;
				//мОбрРез = НайтиОбратноеВхождение(_string,_sourceIndex+1,_source,_maxDist);
				мОбрРез = НайтиОбратноеВхождениеПоМассиву(_stringsTo,_sourceIndex+1,_source,КешСтрокДляСравнения,_maxDist);
				Если НЕ мОбрРез=Неопределено Тогда                                                   
					мРез = Новый Структура("status,start,end,lines","err",_startIndex,_curIndex,lines);
					Прервать;  
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// ХАК
		// ИЛИ до начала функции     
		мФункц = ЭтоНачалоФункцииПроцедуры(_string,_curIndex,_text);
		Если (_curStringIsFunc=Ложь И мФункц.Result=Истина) ИЛИ ПерваяСтрочкаЭтоФункцияКоторойНетВИсточнике=Истина  Тогда
			
			// если этой функций нет в исходном файле, то проматываем ее всю
			ЕстьТакаяФункция = мНастройки.sfunPos.Получить(НРег(мФункц.curNameFunc));
			// проматываем эту функцию
			Если ЕстьТакаяФункция=Неопределено ИЛИ ПерваяСтрочкаЭтоФункцияКоторойНетВИсточнике=Истина Тогда
				Пока _curIndex<_text.Количество()-1 Цикл  
					
					_curIndex = _curIndex+1;
					
					_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[_curIndex],КешСтрокДляСравнения);
					
					Если ЭтоКонецФункцииПроцедуры(_string)=Истина Тогда
						lines.Добавить(_text[_curIndex-1]);
						_curIndex = _curIndex+1;      // позиционируемся на следующую строку 
						lines.Добавить(_text[_curIndex-1]); // сохраняем конец функции или процедуры
						_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[_curIndex],КешСтрокДляСравнения);
						Прервать;
					КонецЕсли;
					
					lines.Добавить(_text[_curIndex-1]);
					
				КонецЦикла;
			Иначе
				Прервать;
			КонецЕсли;
			
		КонецЕсли; 					

		// ХАК
		// ищем до КонецФункции или КонецПроцедуры
		Если _curStringIsFunc=Ложь И ЭтоКонецФункцииПроцедуры(_string)=Истина Тогда
			Прервать;
		КонецЕсли;                 
		
		// если более дистанции
		Если _maxDist<_startIndex-_curIndex Тогда
			Прервать;
		КонецЕсли;
		
		_curIndex = _curIndex+1;   
		
	КонецЦикла;         
	
	Возврат мРез;
	
КонецФункции

Функция НайтиОбратноеВхождениеПоМассиву(_curStringsTo,_startIndex,_text,КешСтрокДляСравнения,_maxDist=1000)
	
	мРез = Неопределено;          
	lines = Новый Массив;  
	CurItem = 0;
	
	// позиция на следующую строку
	_curIndex = _startIndex+1;
	
	Пока _curIndex<_text.Количество() Цикл   		
		
		_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[_curIndex],КешСтрокДляСравнения);
		lines.Добавить(_text[_curIndex-1]);
		
		Если _curStringsTo[CurItem]=_string Тогда
			CurItem=CurItem+1;
			//Прервать;  
		КонецЕсли;		
		
		// если все совпали, тогда мы нашли, то что искали
		Если CurItem=_curStringsTo.Количество() Тогда
			мРез = Новый Структура("start,end,lines",_startIndex,_curIndex,СтрСоединить(lines,Символы.ПС));			
			Прервать;
		КонецЕсли;
		
		// ХАК
		// ищем до КонецФункции или КонецПроцедуры      
		// достигли конца, но не все строки сошлись
		// считаем, что опять блок не подходит
		Если ЭтоКонецФункцииПроцедуры(_string)=Истина Тогда
			Прервать;
		КонецЕсли;                 
		
		
		// ХАК
		// ищем или до начала процедуры     
		Если ЭтоНачалоФункцииПроцедуры(_string,_curIndex,_text).Result=Истина Тогда
			Прервать;
		КонецЕсли;     
		
		// если более дистанции
		// тут нет вхождений, считаем что блок просто удаляется
		Если _maxDist<_startIndex-_curIndex Тогда
			Прервать;
		КонецЕсли;
		
		_curIndex = _curIndex+1;   
		
	КонецЦикла;         
	
	Возврат мРез;
	
КонецФункции

Функция НайтиОбратноеВхождение(_curString,_startIndex,_text,КешСтрокДляСравнения,_maxDist=1000)
	
	мРез = Неопределено;          
	lines = Новый Массив;
	
	// позиция на следующую строку
	_curIndex = _startIndex+1;
	
	Пока _curIndex<_text.Количество() Цикл       
		
		_string = ПолучитьНезависимуюОбработаннуюСтроку(_text[_curIndex],КешСтрокДляСравнения);
		lines.Добавить(_text[_curIndex-1]);
		
		Если _curString=_string Тогда
			мРез = Новый Структура("start,end,lines",_startIndex,_curIndex,СтрСоединить(lines,Символы.ПС));
			Прервать;  
		КонецЕсли;
		_curIndex = _curIndex+1;   
		
		// ХАК
		// ищем до КонецФункции или КонецПроцедуры
		Если _string="конецпроцедуры" ИЛИ _string="конецфункции" Тогда
			Прервать;
		КонецЕсли;                 
		
		// если более дистанции
		Если _maxDist<_startIndex-_curIndex Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;         
	
	Возврат мРез;
	
КонецФункции


Функция НайтиНачалоОкончаниеПроцедурФункций(_text) ЭКспорт
	
	КешСтрокДляСравнения = Новый Соответствие;
	мРез = Новый Структура;
	МассивПозицийФункций = Новый Массив;
	
	curNameFunc = "";  
	curPosFunc = "";    
	curOrderPos = 1;
	СтруктураПоложенияФункции = Новый Структура;
	
	Для _curIndex=0 ПО _text.Количество()-1 Цикл
		
		_textString = ПолучитьНезависимуюОбработаннуюСтроку(_text[_curIndex],КешСтрокДляСравнения); 
		
		// имя функции    
		мФун = ЭтоНачалоФункцииПроцедуры(_textString,_curIndex,_text);
		Если мФун.Result=Истина Тогда
			curNameFunc = мФун.curNameFunc;
			curPosFunc = _curIndex;        
			СтруктураПоложенияФункции = Новый Структура;
			СтруктураПоложенияФункции.Вставить("curNameFunc",curNameFunc);
			СтруктураПоложенияФункции.Вставить("curPosFunc",curPosFunc);      
			СтруктураПоложенияФункции.Вставить("curPosEndFunc",-1);
			СтруктураПоложенияФункции.Вставить("curOrderPos",curOrderPos);
			СтруктураПоложенияФункции.Вставить("typeOfChange","und");
			curOrderPos=curOrderPos+1;
		КонецЕсли;  

		// сохраняем позицию до изменения счетчика
		Если ЭтоКонецФункцииПроцедуры(_textString) Тогда
			curPosEndFunc = _curIndex;               
			СтруктураПоложенияФункции.Вставить("curPosEndFunc",curPosEndFunc);
			МассивПозицийФункций.Добавить(СтруктураПоложенияФункции);
		КонецЕсли;  		
		
	КонецЦикла;        
	
	// сформируем соответствие
	ПозицииФункций = Новый Соответствие;
	Для каждого стр из МассивПозицийФункций Цикл
		ПозицииФункций.Вставить(нРег(стр.curNameFunc),стр);
	КонецЦикла;
	
	мРез.Вставить("funPos",ПозицииФункций);
	мРез.Вставить("funPosMass",МассивПозицийФункций);
	
	Возврат мРез;
КонецФункции

Процедура СинхронизироватьПорядокФнукцийЕслиТребуется(sRes,dRes,sLF,dLF)
	
	КешСтрокДляСравнения = Новый Соответствие;
	sourceIndex = 0;
	destIndex = 0;  
	ПеремещенныеФункции = Новый Массив;                 
	
	// уточним начало функции
	Для ш=0 ПО dRes.funPosMass.Количество()-1 Цикл    
		СтруктураПоложенияФункции = dRes.funPosMass[ш]; 
		ПозицияНачалаТекущейФункции = СтруктураПоложенияФункции.curPosFunc;
		ПозицияУдачногоНачала =  ПозицияНачалаТекущейФункции;
		ж=ПозицияНачалаТекущейФункции-1;
		Пока ж>0 Цикл
			_destString = ПолучитьНезависимуюОбработаннуюСтроку(dLF[ж],КешСтрокДляСравнения);	
			
			// на конец предыдущей функции
			Если ЭтоКонецФункцииПроцедуры(_destString) Тогда
				// берем предыдущую
				ПозицияУдачногоНачала = ж+1;
				Прервать;          				
			КонецЕсли;
			
			// пустая строка, область
			Если НЕ ЗначениеЗаполнено(_destString) 
				ИЛИ Найти(_destString,"#область")
				ИЛИ Найти(_destString,"#конецобласти") Тогда
				// берем предыдущую
				ПозицияУдачногоНачала = ж+1;
				Прервать;          				
			КонецЕсли;
				
			ж=ж-1;
		КонецЦикла;    
		
		Если СтруктураПоложенияФункции.curPosFunc<>ПозицияУдачногоНачала Тогда
			СтруктураПоложенияФункции.curPosFunc=ПозицияУдачногоНачала;
		КонецЕсли;
		
	КонецЦикла;


	// проверяем порядок, если требуется заменяем  
	ПозицияУдачнойВставки = 0; // вначале функции
	Пока sourceIndex<sRes.funPosMass.Количество() И destIndex<dRes.funPosMass.Количество() Цикл
		
		Если sourceIndex<sRes.funPosMass.Количество() Тогда  
			_sourceString = ПолучитьНезависимуюОбработаннуюСтроку(sRes.funPosMass[sourceIndex].curNameFunc,КешСтрокДляСравнения);              
		Иначе                                                                           
			_sourceString = Неопределено;
		КонецЕсли;            
		
		Если destIndex<dRes.funPosMass.Количество() Тогда  
			_destString = ПолучитьНезависимуюОбработаннуюСтроку(dRes.funPosMass[destIndex].curNameFunc,КешСтрокДляСравнения);
		Иначе                                                                           
			_destString = Неопределено;
		КонецЕсли; 
		
		Если _sourceString=_destString Тогда     
			Если dRes.funPosMass[destIndex].typeOfChange<>"ins" Тогда
				ПозицияУдачнойВставки = dRes.funPosMass[destIndex].curPosEndFunc;
			КонецЕсли;
			sourceIndex=sourceIndex+1;
			destIndex=destIndex+1; 
		Иначе          
			// эта функция отсуствует в приемнике?
			dFunc = dRes.funPos.Получить(Нрег(sRes.funPosMass[sourceIndex].curNameFunc));
			// функция удалена, движемся далее по источнику
			Если dFunc=Неопределено Тогда 
				sourceIndex=sourceIndex+1;
			Иначе                           
				// проверим, если этой функции нет в исходной, то менять не будем
				sFunc = sRes.funPos.Получить(Нрег(dRes.funPosMass[destIndex].curNameFunc)); 
				//TODO: тут я все функции переношу в начало, но на самом деле
				// эта проблема в том, что при поиске соотвествия функции источника
				// в функции приемника будет поиск до первой функции, а если функция добавлена между
				// то тут будет проблема, он будет вынужден перенести вверх все остальные функции
				// правильно при сравнении искать функцию входящуюю не до конца функции, а до существующей функции
				// это надо в сравнении допилить
				Если sFunc=Неопределено // И ЛОЖЬ 
					Тогда
					ПозицияУдачнойВставки = dRes.funPosMass[destIndex].curPosEndFunc;
					destIndex=destIndex+1;
				Иначе
					
					// вставляем
					СтруктураПоложенияФункции = Новый Структура;
					СтруктураПоложенияФункции.Вставить("curNameFunc",dFunc.curNameFunc);
					СтруктураПоложенияФункции.Вставить("curPosFunc",dFunc.curPosFunc);      
					СтруктураПоложенияФункции.Вставить("curPosEndFunc",dFunc.curPosEndFunc);
					СтруктураПоложенияФункции.Вставить("curOrderPos",dFunc.curOrderPos);
					СтруктураПоложенияФункции.Вставить("typeOfChange","ins");  
					СтруктураПоложенияФункции.Вставить("goodInsertPos",ПозицияУдачнойВставки+1);  // следующая строка					
					Индекс = dRes.funPosMass.Найти(dRes.funPosMass[destIndex]);
					dRes.funPosMass.Вставить(Индекс,СтруктураПоложенияФункции);
					
					// помечаем, что удалена
					dFunc.typeOfChange="del";        
					
					// запоминаем 
					ПеремещенныеФункции.Добавить(СтруктураПоложенияФункции);
					ПеремещенныеФункции.Добавить(dFunc);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;  
	
	// требуется перетасовать строки в dLF
	Если ПеремещенныеФункции.Количество()>0 Тогда  
		// 1. мы должны найти место куда вставить
		// это первое пустое значение перед функцией, если вплотную написаны, то сразу
		// после окончания предыдущей функции/процедуры
		// 2. мы должны взять строки перемещаемой функции от конца до начала
		// первыйа пустая строка перед функцией, чтобы захватить директиву на сервере или на клиенте
		// и комментарии - описание кода
		// 3. условия прекращения точки вырезки - пустая строка, конец процедуры функции, конец или начало области
		new_dLF = Новый Массив;
		
		СоотвествиеПозиций = Новый Соответствие;
		// сохраним строки
		Для каждого СтруктураПоложенияФункции из ПеремещенныеФункции Цикл      
			// сохранили строки
			Если СтруктураПоложенияФункции.typeOfChange="ins" Тогда
				СтруктураПоложенияФункции.Вставить("МассивПеремещаемыхСтрок",Новый Массив);
				Для ш=СтруктураПоложенияФункции.curPosFunc ПО СтруктураПоложенияФункции.curPosEndFunc Цикл
					СтруктураПоложенияФункции.МассивПеремещаемыхСтрок.Добавить(dLF[ш]);	
				КонецЦикла;
			КонецЕсли;
			// сохраним позицию         
			Если СтруктураПоложенияФункции.typeOfChange="del" Тогда     
				МассивСоответствий = новый Массив;
				МассивСоответствий.Добавить(СтруктураПоложенияФункции);
				СоотвествиеПозиций.Вставить(СтруктураПоложенияФункции.curPosFunc,МассивСоответствий);
			ИначеЕсли СтруктураПоложенияФункции.typeOfChange="ins" Тогда                                    
				МассивСоответствий = СоотвествиеПозиций.Получить(СтруктураПоложенияФункции.goodInsertPos);
				Если МассивСоответствий= Неопределено Тогда
					МассивСоответствий = Новый Массив;
				КонецЕсли;
				МассивСоответствий.Добавить(СтруктураПоложенияФункции);
				СоотвествиеПозиций.Вставить(СтруктураПоложенияФункции.goodInsertPos,МассивСоответствий);
			КонецЕсли; 
		КонецЦикла;  
		
		// формируем новую структуру текстов
		dLF.Добавить("");// добавим еще одну строку, вдруг вставка в конце файла
		Позиция = 0;
		Пока Позиция<dLF.Количество() Цикл
			
			МассивСоответствий = СоотвествиеПозиций.Получить(Позиция);
			
			Если НЕ МассивСоответствий=Неопределено Тогда
				
				Для каждого ПозицияПереноса из МассивСоответствий Цикл	
					// если удаление, тогда тупо пропускаем
					Если ПозицияПереноса.typeOfChange="del" Тогда
						Позиция = Макс(ПозицияПереноса.curPosEndFunc,Позиция);
						// включаем перенос функции
					ИначеЕсли ПозицияПереноса.typeOfChange="ins" Тогда
						new_dLF.Добавить("");
						Для каждого стр из ПозицияПереноса.МассивПеремещаемыхСтрок Цикл
							new_dLF.Добавить(стр);
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;	
			КонецЕсли;
			
			new_dLF.Добавить(dLF[Позиция]);
			
			Позиция=Позиция+1;
			
		КонецЦикла;     
		
		// делаем замену
		dLF = new_dLF;	
		
	КонецЕсли;
	
КонецПроцедуры    
